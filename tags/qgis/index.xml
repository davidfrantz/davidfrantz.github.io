<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>QGIS | DAVID FRANTZ</title>
    <link>https://davidfrantz.github.io/tags/qgis/</link>
      <atom:link href="https://davidfrantz.github.io/tags/qgis/index.xml" rel="self" type="application/rss+xml" />
    <description>QGIS</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><copyright>© 2019-2020 David Frantz</copyright><lastBuildDate>Wed, 09 Sep 2020 00:00:00 +0000</lastBuildDate>
    <image>
      <url>https://davidfrantz.github.io/img/icon-192.png</url>
      <title>QGIS</title>
      <link>https://davidfrantz.github.io/tags/qgis/</link>
    </image>
    
    <item>
      <title>FORCE Tutorial: Spectral Temporal Metrics</title>
      <link>https://davidfrantz.github.io/tutorials/force-stm/stm/</link>
      <pubDate>Wed, 09 Sep 2020 00:00:00 +0000</pubDate>
      <guid>https://davidfrantz.github.io/tutorials/force-stm/stm/</guid>
      <description>&lt;p&gt;&lt;em&gt;This tutorial uses FORCE v. 3.5&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;learning-objective&#34;&gt;&lt;strong&gt;Learning Objective&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;This tutorial explains what Spectral Temporal Metrics are, and how to generate them using the Time Series Analysis (TSA) submodule of the &lt;strong&gt;FORCE Higher Level Processing system (HLPS)&lt;/strong&gt;.&lt;/p&gt;
&lt;h2 id=&#34;what-are-spectral-temporal-metrics&#34;&gt;&lt;strong&gt;What are Spectral Temporal Metrics?&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;There are also other names around, which describe the same concept.
However, regardless of how you name it, Spectral Temporal Metrics (or simply STMs) are band-wise descriptive statistics, which summarize reflectance (or an index derived thereof) within a defined time period.
This can be the annual mean, standard deviation or median.
Before calculating the statistics, the data is quality filtered, e.g. clouds are removed.&lt;/p&gt;



  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://davidfrantz.github.io/img/tutorial-stm-example.png&#34; data-caption=&#34;STM concept (C) Stefan Ernst&#34;&gt;
&lt;img src=&#34;https://davidfrantz.github.io/img/tutorial-stm-example.png&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    STM concept (C) Stefan Ernst
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;p&gt;It is important to note that STMs are statistical aggregations - and not composites as in &lt;em&gt;“we select the full spectrum for the optimal observation”&lt;/em&gt;.
Thus, some care should be taken when dealing with these kinds of metrics: an STM spectrum cannot be interpreted in the classic remote-sensing-textbook sense.
As an example, computing the NDVI from the 25% quantile of red and near infrared reflectance may yield unexpected results as they are not originating from the same acquisition date…
Funny things may happen when you do.
To emphasize this distinction, this is why we generally do not term them composites - but STMs (&lt;em&gt;this is debatable, I know&lt;/em&gt;).&lt;/p&gt;
&lt;p&gt;Anyway, STMs are powerful, yet simple (&lt;em&gt;simple is good!&lt;/em&gt;) metrics that are often used as features for Machine Learning algorithms, both for classification and regression problems.
Due to their robustness (as compared to more advanced metrics) and their spatial completeness, they simplify the extrapolation/mapping of a response variable (qualitative or quantitative, e.g. classification labels or forest biomass) across very large areas.&lt;/p&gt;
&lt;h2 id=&#34;parameterfile&#34;&gt;&lt;strong&gt;Parameterfile&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;STMs are available within the &lt;a href=&#34;https://force-eo.readthedocs.io/en/latest/components/higher-level/tsa/index.html&#34;&gt;Time Series Analysis (TSA)&lt;/a&gt; submodule of the &lt;a href=&#34;https://force-eo.readthedocs.io/en/latest/components/higher-level/index.html&#34;&gt;FORCE Higher Level Processing system (HLPS)&lt;/a&gt;.
You can use &lt;code&gt;force-parameter&lt;/code&gt; to generate an empty parameterfile.&lt;/p&gt;
&lt;p&gt;To familiarize yourself with the TSA submodule, I suggest taking a detour to the &lt;a href=&#34;https://davidfrantz.github.io/tutorials/force-tsi/tsi/&#34;&gt;interpolation tutorial&lt;/a&gt; before advancing.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Temporal extent&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The temporal extent defines the time period, which is used for aggregating the Level 2 observations into STMs.
Broader windows generally result in cleaner metrics, although at the expense of seasonal information.
It is hard to give a suggestion here, as this is a complex decision, which depends on sensors used, data availability, environmental conditions, cloud occurence, phenology, what you want to do with the data etc.
To demonstrate, we are generating annual STMs for entire 2018:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TIME_RANGE = 2018-01-01 2018-12-31&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Sensors&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;FORCE HLPS allows you to easily combine data from different sensors - provided that we only use mutually available bands.
For this tutorial, we are using data from Landsat 8, Sentinel-2A and Sentinel-2B.
We are setting the output resolution to 30m.
For Landsat, this is the native resolution.
For the 10m Sentinel-2, we degrade the resolution using an approximated Point Spread Function (Gaussian lowpass with FWHM = analysis resolution), which approximates the acquisition of data at lower spatial resolution.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;SENSORS = LND08 SEN2A SEN2B
RESOLUTION = 30
REDUCE_PSF = TRUE
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Bands / Indices&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;We will produce STMs for some spectral bands, as well as some indices:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;INDEX = RED NIR SWIR1 NDVI NDBI MNDWI&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Outlier detection&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;If you see cloud remnants in your STMs, you might want to experiment with the outlier detection option.
For now, lets disable it with:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ABOVE_NOISE = 0
BELOW_NOISE = 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Interpolation&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Before temporally aggregating the L2 observations, we can interpolate the time series. Try this out! But for now, let’s go without:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;INTERPOLATE = NONE&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;STMs&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Now, we define the statistics for producing the STMs.
You can specify a list with all statistics at once.
Currently available are&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;ID&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;AVG&lt;/td&gt;
&lt;td&gt;Average&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;STD&lt;/td&gt;
&lt;td&gt;Standard deviation&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MIN&lt;/td&gt;
&lt;td&gt;Minimum&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MAX&lt;/td&gt;
&lt;td&gt;Maximum&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RNG&lt;/td&gt;
&lt;td&gt;Range&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;QXX&lt;/td&gt;
&lt;td&gt;Quantiles, replace XX with any 2-digit number, e.g. Q50 for the median. Multiple quantiles can be given&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;IQR&lt;/td&gt;
&lt;td&gt;Inter-quartile range&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SKW&lt;/td&gt;
&lt;td&gt;Skewness&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;KRT&lt;/td&gt;
&lt;td&gt;Kurtosis&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NUM&lt;/td&gt;
&lt;td&gt;Number of observations (after outlier detection and interpolation)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;mdash;&lt;/td&gt;
&lt;td&gt;&amp;mdash;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Let’s go with these metrics for now:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;STM = Q10 Q25 Q50 Q75 Q90 AVG STD
OUTPUT_STM = TRUE
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Explode Output?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;By default, HLPS will produce multi-band files for each spectral band/index, i.e. you will get one file for each index, which will have as many bands as there are STMs.
If you rather prefer single-band images, i.e. one file for each index and each STM, use&lt;/p&gt;
&lt;p&gt;&lt;code&gt;OUTPUT_EXPLODE = TRUE&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Other parameters&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The other parameters are not relevant for generating STMs. However, please note that you can generate STMs AND use the other options at the same time, e.g. Trend Analysis, Land Surface Phenology, etc. This saves time as data is only read once.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Processing&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Processing is straightforward. Simply use:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;force-higher-level /data/europe/stm/stm.prm
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;number of processing units: 280
 (active tiles: 28, chunks per tile: 10)
________________________________________
Progress:                        100.00%
Time for I/C/O:           087%/008%/004%
ETA:             00y 00m 00d 00h 00m 00s

________________________________________
Real time:       00y 00m 00d 00h 19m 05s
Virtual time:    00y 00m 00d 00h 21m 35s
Saved time:      00y 00m 00d 00h 02m 30s

________________________________________
Virtual I-time:  00y 00m 00d 00h 18m 53s
Virtual C-time:  00y 00m 00d 00h 01m 47s
Virtual O-time:  00y 00m 00d 00h 00m 55s

________________________________________
I-bound time:    00y 00m 00d 00h 17m 10s
C-bound time:    00y 00m 00d 00h 00m 07s
O-bound time:    00y 00m 00d 00h 00m 03s
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After this, we generate a mosaic.
With &lt;code&gt;OUTPUT_EXPLODE = TRUE&lt;/code&gt;, you get one image for each requested index and statistical aggregation, i.e. 42 images in our case:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;force-mosaic /data/europe/stm
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;mosaicking 42 products:
1 2018-2018_001-365_HL_TSA_LNDLG_MNW_STM_AVG.tif
2 2018-2018_001-365_HL_TSA_LNDLG_MNW_STM_Q10.tif
3 2018-2018_001-365_HL_TSA_LNDLG_MNW_STM_Q25.tif
4 2018-2018_001-365_HL_TSA_LNDLG_MNW_STM_Q50.tif
...
40 2018-2018_001-365_HL_TSA_LNDLG_SW1_STM_Q75.tif
41 2018-2018_001-365_HL_TSA_LNDLG_SW1_STM_Q90.tif
42 2018-2018_001-365_HL_TSA_LNDLG_SW1_STM_STD.tif

mosaicking 2018-2018_001-365_HL_TSA_LNDLG_MNW_STM_AVG.tif
26 chips found.

mosaicking 2018-2018_001-365_HL_TSA_LNDLG_MNW_STM_Q25.tif
26 chips found.

...

mosaicking 2018-2018_001-365_HL_TSA_LNDLG_SW1_STM_AVG.tif
26 chips found.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;visualization&#34;&gt;&lt;strong&gt;Visualization&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Visualizing an RGB color composite in QGIS, wherein the 3 bands come from different physical files, does not work out of the box..
Thus, we need to put the required bands into one file. Luckily, a virtual data format suffices.
This example here stacks the 50% quantiles of the reflectance bands, as well as the 90% quantiles of the indices.
For fast visualization, we are computing pyramids.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd /data/europe/stm/mosaic
force-stack *RED_STM_Q50.vrt *NIR_STM_Q50.vrt *SW1_STM_Q50.vrt stack-bands-STM_Q50.vrt
force-stack *NDB_STM_Q90.vrt *NDV_STM_Q90.vrt *MNW_STM_Q90.vrt stack-indices-STM_Q90.vrt
ls *.vrt | parallel force-pyramid {}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;file 1:
  /data/europe/stm/mosaic
  2018-2018_001-365_HL_TSA_LNDLG_RED_STM_Q50.vrt
  9000 4000 1
file 2:
  /data/europe/stm/mosaic
  2018-2018_001-365_HL_TSA_LNDLG_NIR_STM_Q50.vrt
  9000 4000 1
file 3:
  /data/europe/stm/mosaic
  2018-2018_001-365_HL_TSA_LNDLG_SW1_STM_Q50.vrt
  9000 4000 1

Same number of bands detected. Stacking by band.

Band 0001: 2018-2018_001-365_HL_TSA_LNDLG_RED_STM_Q50.vrt band 1
Band 0002: 2018-2018_001-365_HL_TSA_LNDLG_NIR_STM_Q50.vrt band 1
Band 0003: 2018-2018_001-365_HL_TSA_LNDLG_SW1_STM_Q50.vrt band 1

file 1:
  /data/europe/stm/mosaic
  2018-2018_001-365_HL_TSA_LNDLG_NDB_STM_Q90.vrt
  9000 4000 1
file 2:
  /data/europe/stm/mosaic
  2018-2018_001-365_HL_TSA_LNDLG_NDV_STM_Q90.vrt
  9000 4000 1
file 3:
  /data/europe/stm/mosaic
  2018-2018_001-365_HL_TSA_LNDLG_MNW_STM_Q90.vrt
  9000 4000 1

Same number of bands detected. Stacking by band.

Band 0001: 2018-2018_001-365_HL_TSA_LNDLG_NDB_STM_Q90.vrt band 1
Band 0002: 2018-2018_001-365_HL_TSA_LNDLG_NDV_STM_Q90.vrt band 1
Band 0003: 2018-2018_001-365_HL_TSA_LNDLG_MNW_STM_Q90.vrt band 1

computing pyramids for 2018-2018_001-365_HL_TSA_LNDLG_MNW_STM_Q10.vrt
0...10...20...30...40...50...60...70...80...90...100 - done.
computing pyramids for 2018-2018_001-365_HL_TSA_LNDLG_MNW_STM_Q25.vrt
0...10...20...30...40...50...60...70...80...90...100 - done.
...
computing pyramids for stack-bands-STM_Q50.vrt
0...10...20...30...40...50...60...70...80...90...100 - done.
computing pyramids for stack-indices-STM_Q90.vrt
0...10...20...30...40...50...60...70...80...90...100 - done.
&lt;/code&gt;&lt;/pre&gt;



  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://davidfrantz.github.io/img/tutorial-stm-qgis.jpg&#34; data-caption=&#34;RGB composite of STMs - Top: Q50 reflectance - Bottom: Q90 Indices&#34;&gt;
&lt;img src=&#34;https://davidfrantz.github.io/img/tutorial-stm-qgis.jpg&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    RGB composite of STMs - Top: Q50 reflectance - Bottom: Q90 Indices
  &lt;/figcaption&gt;


&lt;/figure&gt;

</description>
    </item>
    
    <item>
      <title>FORCE Tutorial: Interpolation</title>
      <link>https://davidfrantz.github.io/tutorials/force-tsi/tsi/</link>
      <pubDate>Tue, 08 Sep 2020 00:00:00 +0000</pubDate>
      <guid>https://davidfrantz.github.io/tutorials/force-tsi/tsi/</guid>
      <description>&lt;p&gt;&lt;em&gt;This tutorial uses FORCE v. 3.5&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;learning-objective&#34;&gt;&lt;strong&gt;Learning Objective&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;This tutorial introduces the Time Series Analysis (TSA) submodule of the &lt;strong&gt;FORCE Higher Level Processing system (HLPS)&lt;/strong&gt;, shows how to interpolate time series, and how to visualize and animate them via QGIS plugins.&lt;/p&gt;
&lt;h2 id=&#34;why-interpolation&#34;&gt;&lt;strong&gt;Why interpolation?&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Despite regular observations, EO time series are generally not equidistant.
Nominal equidistance is only given for areas that are not covered by orbital overlaps (16 days revisit at nadir for a single Landsat).
For areas in lateral overlaps, we have alternating revisits of 1 and 7 days.
If we are getting closer to the poles, we even get triple, quadruple etc. overlaps, which complicates this alternating pattern.
The same applies if we consider multiple sensors, e.g. two Landsat and two Sentinel-2 satellites.
And of course, nominal revisit != actual revisit.
We cannot see through clouds (unless we are talking radar).
Probably, you want to remove snow observations.
There might have been some sensor or ground segment outages, or the data couldn&#39;t have been processed to our quality requirements (e.g. tier 2 data).
The sensor might not have looked on Earth as the satellite took a detour to avoid space debris etc. etc..&lt;/p&gt;
&lt;p&gt;Interpolation might simply be used to close these gaps.
It smoothes the time series, and thus effectively reduces noise.
Equidistance is established, which might be needed for following processing steps.&lt;/p&gt;
&lt;p&gt;Time Series interpolation is a basic option within the &lt;a href=&#34;https://force-eo.readthedocs.io/en/latest/components/higher-level/tsa/index.html&#34;&gt;Time Series Analysis (TSA)&lt;/a&gt; submodule of the &lt;a href=&#34;https://force-eo.readthedocs.io/en/latest/components/higher-level/index.html&#34;&gt;FORCE Higher Level Processing system (HLPS)&lt;/a&gt;, and may be performed before using more advanced time series analysis methods:&lt;/p&gt;



  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://davidfrantz.github.io/img/force-tsa-workflow.jpg&#34; data-caption=&#34;Time Series Analysis Workflow&#34;&gt;
&lt;img src=&#34;https://davidfrantz.github.io/img/force-tsa-workflow.jpg&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Time Series Analysis Workflow
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;h2 id=&#34;rbf-interpolation&#34;&gt;&lt;strong&gt;RBF interpolation&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;In FORCE, a couple of interpolation methods are implemented.
Most often, we use ensembles of Radial Basis Function (RBF) convolution filters (see this paper &lt;a href=&#34;https://www.sciencedirect.com/science/article/pii/S0303243416301003&#34;&gt;here&lt;/a&gt;).
As this is a convolution filter, no fitting is involved (as e.g. compared to splines or Savitzky-Golay filters), thus the method is really fast, while keeping a good balance between retaining detail and smoothing.&lt;/p&gt;
&lt;p&gt;The method is basically a moving average filter on steroids.
A kernel is moved over the time series, and the observations are weighted according to a Gaussian distribution (Gaussian lowpass).
This means that an observation in the middle of the kernel gets a higher weight.&lt;/p&gt;
&lt;p&gt;Now, data density is usually variable, which means that we have seasons with higher data availability (e.g. in the summer) - and seasons with poor data availability.
For good data situations, we would want to have a narrow Gaussian to more closely follow the actual time series.
For bad data situations, however, a narrow kernel would result in many nodata values and wouldn&#39;t smooth the time series appropriately.&lt;/p&gt;
&lt;p&gt;Therefore, we use multiple kernels of different widths.
The estimates from those kernels are eventually aggregated using a weighted average, wherein the weights correspond to the data availability within each kernel.
This gives preference to the kernel with better data coverage.&lt;/p&gt;
&lt;p&gt;This tutorial will show you how to generate an RBF-interpolated time series, and how to dynamically look at the data.
I will demonstrate this for the island of Crete (greece) in the Mediterranean Sea.
An interpolated time series looks like this:&lt;/p&gt;



  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://davidfrantz.github.io/img/tutorial-tsi-rbf.jpg&#34; data-caption=&#34;Interpolated time series using RBF ensembles&#34;&gt;
&lt;img src=&#34;https://davidfrantz.github.io/img/tutorial-tsi-rbf.jpg&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Interpolated time series using RBF ensembles
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;h2 id=&#34;parameterfile&#34;&gt;&lt;strong&gt;Parameterfile&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;We start by generating an empty TSA parameterfile, and rename the file.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mkdir /data/europe/interpolation
force-parameter /data/europe/interpolation TSA 1
cd /data/europe/interpolation
mv TSA-skeleton.prm tsi.prm
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;TSA
An empty parameter file skeleton was written to
  /data/europe/interpolation/TSA-skeleton.prm
Note that all parameters need to be given, even though some may not be used
with your specific parameterization.
You should rename the file, e.g. my-first-TSA.prm.
Parameterize according to your needs and run with
force-higher-level /data/europe/interpolation/my-first-TSA.prm
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you prefer a more compact parameterfile without all the comments, use &lt;code&gt;0&lt;/code&gt; instead of &lt;code&gt;1&lt;/code&gt; as the last parameter.
The full set of parameters is also documented &lt;a href=&#34;https://force-eo.readthedocs.io/en/latest/components/higher-level/tsa/param.html&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Input / Output directories&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;For this tutorial, we assume that we already have an existing Level 2 ARD datapool, which contains preprocessed data for multiple years (see &lt;a href=&#34;https://davidfrantz.github.io/tutorials/force-ard/l2-ard/&#34;&gt;ARD tutorial&lt;/a&gt;).
The parent directory of this datapool goes into the &lt;code&gt;DIR_LOWER&lt;/code&gt; parameter.
The &lt;code&gt;DIR_HIGHER&lt;/code&gt; parameter names the output directory, where the interpolated time series will be generated (although technically possible, I suggest to use a different file path). Example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;DIR_LOWER = /data/europe/level2
DIR_HIGHER = /data/europe/interpolation
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Analysis mask&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;As we are only interested in the land surface - and there is a lot of water around Crete - we use a processing mask.
Have a look at the &lt;a href=&#34;https://davidfrantz.github.io/tutorials/force-masks/masks/&#34;&gt;processing mask tutorial&lt;/a&gt; for further details.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mkdir -p /data/europe/masks
cp /data/europe/level2/datacube-definition.prj -t /data/europe/masks
force-cube /data/gis/admin/crete.gpkg /data/europe/masks rasterize 30
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;0...10...20...30...40...50...60...70...80...90...100 - done.
0...10...20...30...40...50...60...70...80...90...100 - done.
0...10...20...30...40...50...60...70...80...90...100 - done.
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the parameterfile, use the masks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;DIR_MASK = /data/europe/masks
BASE_MASK = crete.tif
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Output options&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;For interoperability with the QGIS plugins, we will generate one output image (for each index) in GeoTiff format, which will have the interpolated dates as bands:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;OUTPUT_FORMAT = GTiff
OUTPUT_EXPLODE = FALSE
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;All other parameters are not relevant for now.
However, please note that you can generate a lot of time series based outputs at the same time, e.g. Trend Analysis, Land Surface Phenology, etc.
This saves time as data is only read once.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spatial extent&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;FORCE HLPS requires a square processing extent, which can be set using &lt;code&gt;X_TILE_RANGE&lt;/code&gt; and &lt;code&gt;Y_TILE_RANGE&lt;/code&gt;. Then, if the extent of our region of interest is not square, we can further refine the processing extent by specifying a tile allow-list (&lt;code&gt;FILE_TILE&lt;/code&gt;). Please see the &lt;a href=&#34;https://davidfrantz.github.io/tutorials/force-datacube/datacube/&#34;&gt;datacube tutorial&lt;/a&gt; for more details, and I also suggest you to have a look at the &lt;a href=&#34;https://force-eo.readthedocs.io/en/latest/components/higher-level/hl-compute.html&#34;&gt;computing model of HLPS&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;There are different ways to obtain these values, e.g. by generating, and filtering a shapefile with tiles via &lt;code&gt;force-tabulate-grid&lt;/code&gt;. The easiest way, however, is to use &lt;code&gt;force-tile-extent&lt;/code&gt; with a vector geometry. Example for Crete, Greece:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;force-tile-extent /data/gis/admin/crete.gpkg /data/europe/level2 /data/europe/interpolation/crete.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Suggested Processing extent:
X_TILE_RANGE = 103 111
Y_TILE_RANGE = 101 105

Processing extent is not square.
Suggest to use the tile allow-list:
FILE_TILE = /data/europe/interpolation/crete.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Block size&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The block size is a parameter that you should only adjust if you are running in RAM-shortages.
&lt;em&gt;First, try the default value and don’t worry&lt;/em&gt;.
However, if the program is &lt;code&gt;killed&lt;/code&gt; by the system, this can be mitigated by adjusting &lt;code&gt;BLOCK_SIZE&lt;/code&gt;.
Please have a look at the &lt;a href=&#34;https://force-eo.readthedocs.io/en/latest/components/higher-level/hl-compute.html&#34;&gt;computing model&lt;/a&gt; to understand how blocks are implemented and used in FORCE.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;NOTE:&lt;/em&gt;&lt;/strong&gt;  The block size is a value, which was set in Level 2 Processing; thus the default block size aligns with the physical layout of the files, and can be considered optimal for reading speed. If you adjust it, it is recommended to use a block size, which is a fraction of the original block size (without remainder, e.g. 1/2 of the original value).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Quality screening&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;This here is &lt;strong&gt;super-important,&lt;/strong&gt; and cannot be stressed enough!&lt;/p&gt;
&lt;p&gt;Without proper quality screening, the results will look like s#%$, trash-in, trash-out!
By default, FORCE screens for nodata values, various cloud types, cloud shadows, snow, sub-zero or saturated reflectance.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;SCREEN_QAI = NODATA CLOUD_OPAQUE CLOUD_BUFFER CLOUD_CIRRUS CLOUD_SHADOW SNOW SUBZERO SATURATION
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In addition, recognizing that cloud masks are never perfect, TSA offers an outlier detection routine.
This screens each pixel’s time series and might be used to remove undetected cloud, cloud shadow, or snow remnants.
The outlier detection is iteratively removing outliers until the time series noise is smaller than the given value.
Note however: this method might also remove some “valid” data points, e.g. mowing events in intensively managed grasslands.
This risk increases with decreasing data availability.&lt;/p&gt;
&lt;p&gt;Following the outlier removal, there is an inliner restoration.
If an observation (flagged as cloud, cloud shadow etc.) fits well into the time series trajectory, it will be restored.&lt;/p&gt;
&lt;p&gt;For our purpose, using this option is fine, thus, let&#39;s keep the default values:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ABOVE_NOISE = 3
BELOW_NOISE = 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Temporal extent, Sensor, Index&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;To eventually generate a long term animation, let’s use 30 years of Landsat data:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;TIME_RANGE = 1990-01-01 2019-12-31
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;FORCE HLPS allows you to easily combine data from different sensors - provided that we only use mutually available bands.
For this tutorial, we are using data from the Landsat sensors:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;SENSORS = LND04 LND05 LND07 LND08
RESOLUTION = 30
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;All processing in the TSA submodule is performed band-wise.
You can choose from a fairly long list of spectral bands and indices (see &lt;a href=&#34;https://force-eo.readthedocs.io/en/latest/components/higher-level/tsa/param.html&#34;&gt;here&lt;/a&gt;).
HLPS will only read required bands to reduce I/O.
In order to generate a nice-looking and information-rich animation, we are using the three tasseled cap components:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;INDEX = TC-BRIGHT TC-GREEN TC-WET
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Interpolation&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Now, let’s define the interpolation parameters.
We wil be using the RBF interpolation to create a smoothed time series with 16-day interpolation steps.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;INTERPOLATE = RBF
INT_DAY = 16
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We are commonly using following widths for the gaussians. The width (in days) refers to full-width-at-half-maximum.
This generally works fine, but feel free to experiment here.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;RBF_SIGMA = 8 16 32
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The cutoff parameter determines the width of the kernels.
It works similar to the confidence level in statistical tests, i.e. 0.95 means that we cut the kernel such that 95% of the Gaussian is retained.
Essentially, this paramter determines how many nodata values will remain in the time series.
You will have less nodata values with values closer to one.
However, the interpolated values will also be less reliable when the next valid observations are too far away (remember: trash-in, trash-out).
It also determines processing speed: more narrow kernels are faster.
Commonly, we are using the default value &lt;code&gt;0.95&lt;/code&gt;.
However, as our primary goal is to generate a nice-looking animation, we bump this parameter up:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;RBF_CUTOFF = 0.995
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;..and of course, we request outputting the interpolated time series:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;OUTPUT_TSI = TRUE
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Parallelization&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HLPS uses a computing model, which &lt;em&gt;streams&lt;/em&gt; the data.
Please have a detailed look the at &lt;a href=&#34;https://force-eo.readthedocs.io/en/latest/components/higher-level/hl-compute.html&#34;&gt;computing model of HLPS&lt;/a&gt;.
Most often, generating interpolated time series (without doing anything else) is input-, or output-bound.
However, this strongly varies with data density, the number of requested indices, disc speed (SSD vs HDD, RAID or not, …), CPU clock speed, if you read/write from/to different (or the same) discs etc&amp;hellip;
The progress bar will tell you how much time is spent for reading, computing, and writing.
This helps you identify if your job is e.g. input-limited. You might want to adjust the settings accordingly (also note that you may have more or less CPUs than me).
Please also note: fairly often, inexperienced users tend to overdo parallel reads/writes beyond a value that is reasonable - if reading/writing doesn’t accelerate when you add more CPUs, this is likely the case (you might even slow down your job by overdoing I/O).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;NTHREAD_READ = 8
NTHREAD_COMPUTE = 7
NTHREAD_WRITE = 3
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;processing&#34;&gt;&lt;strong&gt;Processing&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Processing is straightforward:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;force-higher-level /data/europe/interpolation/tsi.prm
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;number of processing units: 280
 (active tiles: 28, chunks per tile: 10)
________________________________________
Progress:                        100.00%
Time for I/C/O:           054%/037%/008%
ETA:             00y 00m 00d 00h 00m 00s

________________________________________
Real time:       00y 00m 00d 00h 58m 41s
Virtual time:    00y 00m 00d 01h 32m 54s
Saved time:      00y 00m 00d 00h 34m 13s

________________________________________
Virtual I-time:  00y 00m 00d 00h 50m 30s
Virtual C-time:  00y 00m 00d 00h 34m 31s
Virtual O-time:  00y 00m 00d 00h 07m 53s

________________________________________
I-bound time:    00y 00m 00d 00h 23m 42s
C-bound time:    00y 00m 00d 00h 07m 10s
O-bound time:    00y 00m 00d 00h 00m 26s
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After this, we do some postprocessing for simplified data handling, and to prepare the data for ingestion into the QGIS plugins.
First, we generate a mosaic:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;force-mosaic /data/europe/interpolation
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;mosaicking 3 products:
1 1990-2019_001-365_HL_TSA_LNDLG_TCB_TSI.tif
2 1990-2019_001-365_HL_TSA_LNDLG_TCG_TSI.tif
3 1990-2019_001-365_HL_TSA_LNDLG_TCW_TSI.tif

mosaicking 1990-2019_001-365_HL_TSA_LNDLG_TCW_TSI.tif
27 chips found.

mosaicking 1990-2019_001-365_HL_TSA_LNDLG_TCB_TSI.tif
27 chips found.

mosaicking 1990-2019_001-365_HL_TSA_LNDLG_TCG_TSI.tif
27 chips found.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then, we build a four-dimensional stack from the three tasseled cap components.
This stack is sorted by date, but interleaved by thematic band.
This data model is a prerequisite to the usage of the following QGIS plugins.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;NOTE:&lt;/em&gt;&lt;/strong&gt; For very long time series, &lt;code&gt;force-stack&lt;/code&gt; still seems a bit slow - but at least it works&amp;hellip;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd mosaic
force-stack *TCB*TSI.vrt *TCG*TSI.vrt *TCW*TSI.vrt 4D-Tasseled-Cap-TSI.vrt
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;file 1:
  /data/europe/interpolation/mosaic
  1990-2019_001-365_HL_TSA_LNDLG_TCB_TSI.vrt
  9000 4000 684
file 2:
  /data/europe/interpolation/mosaic
  1990-2019_001-365_HL_TSA_LNDLG_TCG_TSI.vrt
  9000 4000 684
file 3:
  /data/europe/interpolation/mosaic
  1990-2019_001-365_HL_TSA_LNDLG_TCW_TSI.vrt
  9000 4000 684

Same number of bands detected. Stacking by band.

Band 0001: 1990-2019_001-365_HL_TSA_LNDLG_TCB_TSI.vrt band 1
Band 0002: 1990-2019_001-365_HL_TSA_LNDLG_TCG_TSI.vrt band 1
Band 0003: 1990-2019_001-365_HL_TSA_LNDLG_TCW_TSI.vrt band 1
Band 0004: 1990-2019_001-365_HL_TSA_LNDLG_TCB_TSI.vrt band 2
Band 0005: 1990-2019_001-365_HL_TSA_LNDLG_TCG_TSI.vrt band 2
Band 0006: 1990-2019_001-365_HL_TSA_LNDLG_TCW_TSI.vrt band 2
Band 0007: 1990-2019_001-365_HL_TSA_LNDLG_TCB_TSI.vrt band 3
Band 0008: 1990-2019_001-365_HL_TSA_LNDLG_TCG_TSI.vrt band 3
Band 0009: 1990-2019_001-365_HL_TSA_LNDLG_TCW_TSI.vrt band 3
...
Band 2050: 1990-2019_001-365_HL_TSA_LNDLG_TCB_TSI.vrt band 684
Band 2051: 1990-2019_001-365_HL_TSA_LNDLG_TCG_TSI.vrt band 684
Band 2052: 1990-2019_001-365_HL_TSA_LNDLG_TCW_TSI.vrt band 684
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For rapid display, we compute pyramids:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;force-pyramid 4D-Tasseled-Cap-TSI.vrt
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;/data/europe/interpolation/mosaic/4D-Tasseled-Cap-TSI.vrt
computing pyramids for 4D-Tasseled-Cap-TSI.vrt
...10...20...30...40...50...60...70...80...90...100 - done.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;visualization&#34;&gt;&lt;strong&gt;Visualization&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Layer Styling&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Let&#39;s drag&#39;n&#39;drop the &lt;code&gt;4D-Tasseled-Cap-TSI.vrt&lt;/code&gt; into &lt;strong&gt;QGIS&lt;/strong&gt;, and visualize the Tasseled Cap components of the 1st timestamp as RGB composite (using the &lt;code&gt;Multiband color&lt;/code&gt; renderer), i.e. we put the first three bands into the red (Brightness), green (Greenness), and blue (Wetness) channels for intuitive color interpretation.
The chosen stretch will later be applied to the animation as well.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Time Series Plots&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;You can conveniently look at the pixels&#39;s time series using the &lt;a href=&#34;https://raster-data-plotting.readthedocs.io/en/latest/&#34;&gt;Raster Data Plotting&lt;/a&gt; plugin (© &lt;a href=&#34;mailto:andreas.rabe@geo.hu-berlin.de&#34;&gt;Andreas Rabe&lt;/a&gt;).
I am using red, green, and blue lines for the Brigthness, Greenness, and Wetness components, respectively, and decrease the symbol size a bit.&lt;/p&gt;



  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://davidfrantz.github.io/img/tutorial-tsi-rdp.jpg&#34; data-caption=&#34;Raster Data Plotting plugin&#34;&gt;
&lt;img src=&#34;https://davidfrantz.github.io/img/tutorial-tsi-rdp.jpg&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Raster Data Plotting plugin
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;Time Series Animation&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Let&#39;s use the &lt;a href=&#34;https://raster-timeseries-manager.readthedocs.io/en/latest/&#34;&gt;Raster Timeseries Manager&lt;/a&gt; plugin (© &lt;a href=&#34;mailto:andreas.rabe@geo.hu-berlin.de&#34;&gt;Andreas Rabe&lt;/a&gt;) to generate a web- or presentation-ready animation.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;SETUP:&lt;/em&gt;&lt;/strong&gt;  For preparing the animation, go to the plugin&#39;s &lt;code&gt;System&lt;/code&gt; tab.
This needs to be done only once and will set up all necessary tools for saving the animation.
For this, you need to install &lt;a href=&#34;https://imagemagick.org/script/download.php&#34;&gt;ImageMagick&lt;/a&gt;, and then tell the plugin where the &lt;code&gt;imagemagick&lt;/code&gt; and &lt;code&gt;ffmpeg&lt;/code&gt; executables are located.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Simply select &lt;code&gt;4D-Tasseled-Cap-TSI&lt;/code&gt; in the &lt;code&gt;Timeseries&lt;/code&gt; field.
Now, you can already look at the animation (hit play &lt;code&gt;&amp;gt;&lt;/code&gt;).
While the animation is running, you can even pan and zoom in the map canvas.
IMHO, this is a great way of virtually exploring 4D data!&lt;/p&gt;
&lt;p&gt;In the temporal tab, you can set the temporal range for the animation.
For the animation shown below, I only use the last 5 years of data (otherwise the GIF will be too large).&lt;/p&gt;
&lt;p&gt;For saving the animation, go to the &lt;code&gt;Video Creator&lt;/code&gt; tab, and set an output directory.
The export process takes two steps:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Export the frames as images.
This is done by pushing the movie tape button.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;NOTE:&lt;/em&gt;&lt;/strong&gt; The size of the exported images depends on the size of the map canvas.
This will have a direct effect on the size of the final animation.
Adjust the canvas size to your needs.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Generate the animation by pushing the &lt;code&gt;MP4&lt;/code&gt; or &lt;code&gt;GIF&lt;/code&gt; button.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;



  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://davidfrantz.github.io/img/tutorial-tsi-rtm.gif&#34; data-caption=&#34;Animation of interpolated Tasseled Cap time series&#34;&gt;
&lt;img src=&#34;https://davidfrantz.github.io/img/tutorial-tsi-rtm.gif&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Animation of interpolated Tasseled Cap time series
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;p&gt;That&#39;s it. Have fun exploring your 4D data.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>FORCE Tutorial: Quality Bits a.k.a. Cloud Masks etc.</title>
      <link>https://davidfrantz.github.io/tutorials/force-qai/qai/</link>
      <pubDate>Mon, 03 Feb 2020 00:00:00 +0000</pubDate>
      <guid>https://davidfrantz.github.io/tutorials/force-qai/qai/</guid>
      <description>&lt;p&gt;&lt;em&gt;This tutorial uses FORCE v. 3.0&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;learning-objective&#34;&gt;&lt;strong&gt;Learning Objective&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;This tutorial will explain what quality bits are, how quality bits are implemented in &lt;strong&gt;FORCE&lt;/strong&gt;, how to visualize them, and how to deal with them in Higher Level Processing.&lt;/p&gt;
&lt;h2 id=&#34;what-are-quality-bits&#34;&gt;&lt;strong&gt;What are quality bits?&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;FORCE L2PS&lt;/strong&gt; provides a description of the quality of each pixel in the form of quality bits. This bit-packed information allows users to apply per pixel filters to all Level 2 products. The bits represent combinations of surface, atmospheric, and processing-related conditions that can affect the overall usefulness of a given pixel for a particular application. The success of any follow-up analysis depends on the rigorous usage of these information!
A good explanation of quality bits is given by the &lt;a href=&#34;https://www.usgs.gov/land-resources/nli/landsat/landsat-collection-1-level-1-quality-assessment-band?qt-science_support_page_related_con=0#qt-science_support_page_related_con&#34;&gt;USGS&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The bit-packed information in the QA bands is a translation of binary strings. For example, the integer value “1” translates to the binary value “0001.” The binary value “0001” has 4 bits, written right to left as bits 0 (“1”), 1 (“0”), 2 (“0”), and 3 (“0”). Each of the bits 0-3 represents a condition that can affect the calculation of a physical value. [&amp;hellip;] If the condition is true, the bit is set to “1,” or “0” if false.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;sounds-complicated-why-not-use-a-scene-classification&#34;&gt;&lt;strong&gt;Sounds complicated… Why not use a scene classification?&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Although interpretation of quality bits is not immediate to humans, they do possess quite some advantages. As opposed to a scene classification, quality bits allow the flagging of multiple conditions, e.g. ice clouds, cloud shadows on top of clouds or snow, high aerosol load and cloud, etc. If a 16bit Integer is used for storing the quality bits, up to 16 different conditions can co-exist in any possible combination. In a scene classification, only one condition can be stored, and the algorithm developer needs to make assumptions on the priority of the conditions; however these may differ from application to application. Quality bits allow to store all these information in a single  image. From a technical perspective, quality bits save disc space, and reduce the I/O load for follow-up analyses.&lt;/p&gt;
&lt;h2 id=&#34;quality-bits-in-force&#34;&gt;&lt;strong&gt;Quality bits in FORCE&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;In &lt;strong&gt;FORCE&lt;/strong&gt;, the quality bits are found in the Quality Assurance Information (&lt;code&gt;QAI&lt;/code&gt;) product, which is an integral part of each Level 2 dataset, and is alway present next to the reflectance images (&lt;code&gt;BOA&lt;/code&gt; or &lt;code&gt;TOA&lt;/code&gt;).
When generating Best Available Pixel (&lt;code&gt;BAP&lt;/code&gt;) composites (Level 3), the bit flags of the selected observation are stored in the first band of the composite information (&lt;code&gt;INF&lt;/code&gt;) product.
Currently &lt;strong&gt;FORCE&lt;/strong&gt; implements a 16bit QAI layer with 12 quality bits, some of them as double-bit words:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Bit No.&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Parameter name&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Bit comb.&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Integer&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;State&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Valid data&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;valid&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;no data&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;1–2&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Cloud state&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;00&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;clear&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;01&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;less confident cloud (i.e., buffered cloud 300 m)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;10&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;confident, opaque cloud&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;11&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;cirrus&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Cloud shadow flag&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;no&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Snow flag&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;no&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Water flag&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;no&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;6–7&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Aerosol state&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;00&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;estimated (best quality)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;01&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;interpolated (mid quality)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;10&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;high (aerosol optical depth &amp;gt; 0.6, use with caution)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;11&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;fill (global fallback, low quality)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;8&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Subzero flag&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;no&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;yes (use with caution)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;9&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Saturation flag&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;no&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;yes (use with caution)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;10&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;High sun zenith flag&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;no&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;yes (sun elevation &amp;lt; 15°, use with caution)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;11–12&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Illumination state&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;00&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;good (incidence angle &amp;lt; 55°, best quality for top. correction)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;01&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;medium (incidence angle 55°–80°, good quality for top. correction)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;10&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;poor (incidence angle &amp;gt; 80°, low quality for top. correction)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;11&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;shadow (incidence angle &amp;gt; 90°, no top. correction applied)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;13&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Slope flag&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;no (cosine correction applied)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;yes (enhanced C-correction applied)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;14&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Water vapor flag&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;measured (best quality, only Sentinel-2)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;fill (scene average, only Sentinel-2)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;15&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Empty&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;TBD&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Nodata values are values where nothing was observed, where auxiliary data was not given (e.g. nodata in DEM), or
where data is substantially corrupt (e.g. impulse noise, or when the surface reflectance estimate is &amp;gt; 2.0 or &amp;lt; -1.0)&lt;/li&gt;
&lt;li&gt;Clouds are given in three categories, i.e. opaque clouds (confident cloud), buffered clouds (300m; less confident cloud), and cirrus clouds.&lt;/li&gt;
&lt;li&gt;Cloud shadows are detected on the basis of the cloud layer. If a cloud is missed, the cloud shadow is missed, too. If a false
positive cloud is detected, false positive cloud shadows follow.&lt;/li&gt;
&lt;li&gt;Aerosol Optical Depth is estimated for fairly coarse grid cells. If there is no valid AOD estimation in any cell, values are
interpolated. If there is no valid AOD estimation for the complete image, a fill value is assigned (AOD is guessed). If AOD @550nm is higher than 0.6, it is flagged as high aerosol; this is not necessarily critical, but should be used with caution (see subzero flag).&lt;/li&gt;
&lt;li&gt;If the surface reflectance estimate in any band is &amp;lt; 0, the subzero flag is set. This can point to overestimation of AOD.&lt;/li&gt;
&lt;li&gt;If DNs were saturated, or if the surface reflectance estimate in any band is &amp;gt; 1, the saturation flag is set.&lt;/li&gt;
&lt;li&gt;If sun elevation is smaller than 15°, the high sun zenith flag is set. Use this data with caution, radiative transfer computations might be out of specification.&lt;/li&gt;
&lt;li&gt;The illumination state is related to the quality of the topographic correction. If the incidence angle is smaller than 55°, quality is best. If the incidence angle is larger than 80°, the quality of the topographic correction is low, and data artefacts are possible. If the area is not illuminated at all, no topographic correction is done (values are the same as without topographic correction).&lt;/li&gt;
&lt;li&gt;The slope flag indicates whether a simple cosine correction (slope ≤ 2°) was used for topographic correction, or if the enhanced C-correction was used (slope &amp;gt; 2°).&lt;/li&gt;
&lt;li&gt;The water vapor flag indicates whether water vapor was estimated, or if the scene average was used to fill. Water vapor is not estimated over water and cloud shadow pixels. This flag only applies to Sentinel-2 images.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;visualization&#34;&gt;&lt;strong&gt;Visualization&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Visualizing the raw QAI image is pretty meaningless. Don’t be surprised that the integers do not resemble any of the patterns you would expect (e.g. cloud distribution).&lt;/p&gt;



  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://davidfrantz.github.io/img/tutorial-qai-boa.jpg&#34; data-caption=&#34;Sentinel-2B image over Berlin, 01.07.2019; left: RGB image; right: quality bits&#34;&gt;
&lt;img src=&#34;https://davidfrantz.github.io/img/tutorial-qai-boa.jpg&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Sentinel-2B image over Berlin, 01.07.2019; left: RGB image; right: quality bits
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;h3 id=&#34;quicklooks&#34;&gt;&lt;strong&gt;Quicklooks&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Since v. 3.0, &lt;strong&gt;FORCE L2PS&lt;/strong&gt; can output quicklook images for each Level 2 dataset (&lt;code&gt;OVV&lt;/code&gt; = overview product). These thumbnails serve as first impression of image quality. Some of the quality conditions are superimposed on the RGB images. Opaque clouds are shown in pink, cirrus clouds in red, cloud shadows in cyan, snow in yellow, saturated pixels in orange, and sub-zero reflectance values in a greenish tone. The overview for the QAI image from above is shown here:&lt;/p&gt;



  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://davidfrantz.github.io/img/tutorial-qai-ovv.jpg&#34; data-caption=&#34;Quicklook image generated by FORCE L2PS; pink: opaque clouds; cyan: cloud shadows&#34;&gt;
&lt;img src=&#34;https://davidfrantz.github.io/img/tutorial-qai-ovv.jpg&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Quicklook image generated by &lt;strong&gt;FORCE L2PS&lt;/strong&gt;; pink: opaque clouds; cyan: cloud shadows
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;h3 id=&#34;inflate-quality-bits&#34;&gt;&lt;strong&gt;Inflate quality bits&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;A full deciphering of all quality bits to individual quality masks can be generated with &lt;strong&gt;FORCE&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;force-qai-inflate
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Usage: force-qai-inflate QAI dir format
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;force-qai-inflate /data/level2/X0069_Y0043/20190701_LEVEL2_SEN2B_QAI.tif ~/temp GTiff
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This program generates a 12-band image, where each of the flags (see table above) is written to a separate band. However, force-qai-inflate was not designed to generate inflated masks for each and every Level 2 product in a routine manner due to the computational and disc-space related overhead. We strongly recommend to make use of  the bits directly (see remaining part of the tutorial).&lt;/p&gt;



  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://davidfrantz.github.io/img/tutorial-qai-cld.jpg&#34; data-caption=&#34;Quality bits; left: cloud state; right: cloud shadow flag&#34;&gt;
&lt;img src=&#34;https://davidfrantz.github.io/img/tutorial-qai-cld.jpg&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Quality bits; left: cloud state; right: cloud shadow flag
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;h3 id=&#34;quality-bit-rendering-in-qgis&#34;&gt;&lt;strong&gt;Quality bit rendering in QGIS&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;There is a nice QGIS plugin from my colleague &lt;a href=&#34;https://www.geographie.hu-berlin.de/en/professorships/eol/people/labmembers/benjamin_jakimow&#34;&gt;Benjamin Jakimow&lt;/a&gt;, which can visualize quality bits in QGIS &lt;em&gt;on the fly&lt;/em&gt;. Quality bit inflating is not necessary anymore! The &lt;a href=&#34;http://plugins.qgis.org/plugins/BitFlagRenderer/&#34;&gt;Bit Flag Renderer plugin&lt;/a&gt; provides a new renderer for QGIS, with which any quality bit product can flexibly be visualized. The plugin includes predefined bit visualization rules for the &lt;strong&gt;FORCE&lt;/strong&gt; QAI bits. The default visualization matches the information and colors from the quicklook images described above):&lt;/p&gt;



  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://davidfrantz.github.io/img/tutorial-qai-bfr.jpg&#34; data-caption=&#34;Bit Flag Renderer in QGIS displaying a quality bit layer on-the-fly with the pre-defined FORCE settings&#34;&gt;
&lt;img src=&#34;https://davidfrantz.github.io/img/tutorial-qai-bfr.jpg&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Bit Flag Renderer in QGIS displaying a quality bit layer on-the-fly with the pre-defined FORCE settings
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;h2 id=&#34;quality-masking-in-higher-level-processing&#34;&gt;&lt;strong&gt;Quality masking in Higher Level Processing&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;For follow-up processing and analyses, the usage of the QAI information is key, e.g. to exclude clouds. In all &lt;strong&gt;FORCE Higher Level routines&lt;/strong&gt;, quality masking is done on the fly, and the user has full control about what condition(s) to filter. The parameter &lt;code&gt;SCREEN_QAI&lt;/code&gt; provides a simple mechanism to mask out any combination of conditions using any of the following keywords: &lt;em&gt;NODATA, CLOUD_OPAQUE, CLOUD_BUFFER, CLOUD_CIRRUS, CLOUD_SHADOW, SNOW, WATER, AOD_FILL, AOD_HIGH, AOD_INT, SUBZERO, SATURATION, SUN_LOW, ILLUMIN_NONE, ILLUMIN_POOR, ILLUMIN_LOW, SLOPED, WVP_NONE&lt;/em&gt;. The default parametrization is to filter out nodata, clouds, cloud shadows, snow, saturated or subzero reflectance:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SCREEN_QAI = NODATA CLOUD_OPAQUE CLOUD_BUFFER CLOUD_CIRRUS CLOUD_SHADOW SNOW SUBZERO SATURATION&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Following images illustrate the effect of quality filtering on an average reflectance image generated by using all available observations over a 3 month period (using Spectral Temporal Metrics in the &lt;strong&gt;Time Series Analysis module&lt;/strong&gt;). The left image was produced by filtering nodata values only, the right image was produced using the default quality screening.&lt;/p&gt;



  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://davidfrantz.github.io/img/tutorial-qai-avg.jpg&#34; data-caption=&#34;Average reflectance over three month; left: not using quality bits; right with quality bits&#34;&gt;
&lt;img src=&#34;https://davidfrantz.github.io/img/tutorial-qai-avg.jpg&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Average reflectance over three month; left: &lt;strong&gt;not using&lt;/strong&gt; quality bits; right &lt;strong&gt;with&lt;/strong&gt; quality bits
  &lt;/figcaption&gt;


&lt;/figure&gt;

</description>
    </item>
    
  </channel>
</rss>
